import numpy as np
import pandas as pd
train = pd.read_csv('C:/Users/hedaa/Desktop/train.csv')
test = pd.read_csv('C:/Users/hedaa/Desktop/test.csv')
(9557, 143)
(23856, 142)

Finding the target variable
for i in train.columns:
    if i not in test.columns:
        print("Our Target variable is {}".format(i))
Our Target variable is Target
Understanding the type of data
train.info()    
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 9557 entries, 0 to 9556
Columns: 143 entries, Id to Target
dtypes: float64(8), int64(130), object(5)
memory usage: 10.4+ MB
#lets explore each different types of datasets
for i in train.columns:
    a=train[i].dtype
    if a == 'object':
        print(i)
Id
idhogar
dependency
edjefe
edjefa
for i in train.columns:
    a = train[i].dtype
    if a == 'float':
        print(i)
v2a1
v18q1
rez_esc
meaneduc
overcrowding
SQBovercrowding
SQBdependency
SQBmeaned
for i in train.columns:
    a=train[i].dtype
    if a == 'int64':
        print(i)
hacdor
rooms
hacapo
v14a
refrig
v18q
r4h1
r4h2
r4h3
r4m1
r4m2
r4m3
r4t1
r4t2
r4t3
tamhog
tamviv
escolari
hhsize
paredblolad
paredzocalo
paredpreb
pareddes
paredmad
paredzinc
paredfibras
paredother
pisomoscer
pisocemento
pisoother
pisonatur
pisonotiene
pisomadera
techozinc
techoentrepiso
techocane
techootro
cielorazo
abastaguadentro
abastaguafuera
abastaguano
public
planpri
noelec
coopele
sanitario1
sanitario2
sanitario3
sanitario5
sanitario6
energcocinar1
energcocinar2
energcocinar3
energcocinar4
elimbasu1
elimbasu2
elimbasu3
elimbasu4
elimbasu5
elimbasu6
epared1
epared2
epared3
etecho1
etecho2
etecho3
eviv1
eviv2
eviv3
dis
male
female
estadocivil1
estadocivil2
estadocivil3
estadocivil4
estadocivil5
estadocivil6
estadocivil7
parentesco1
parentesco2
parentesco3
parentesco4
parentesco5
parentesco6
parentesco7
parentesco8
parentesco9
parentesco10
parentesco11
parentesco12
hogar_nin
hogar_adul
hogar_mayor
hogar_total
instlevel1
instlevel2
instlevel3
instlevel4
instlevel5
instlevel6
instlevel7
instlevel8
instlevel9
bedrooms
tipovivi1
tipovivi2
tipovivi3
tipovivi4
tipovivi5
computer
television
mobilephone
qmobilephone
lugar1
lugar2
lugar3
lugar4
lugar5
lugar6
area1
area2
age
SQBescolari
SQBage
SQBhogar_total
SQBedjefe
SQBhogar_nin
agesq
Target
Check if there is a house without a family head
check_leader = train.groupby('idhogar')['parentesco1'].sum()
​
#Check for head
no_head = train.loc[train['idhogar'].isin(check_leader[check_leader == 0].index), :]
print('There are {} households without a head.'.format(no_head['idhogar'].nunique()))
There are 15 households without a head.
households_no_head_equal = train.groupby('idhogar')['Target'].apply(lambda x: x.nunique() == 1)
print('{} Households with no head have different labels.'.format(sum(households_no_head_equal == False)))
85 Households with no head have different labels.
# Dropping ID variable
train.drop(['Id', 'idhogar'], axis = 1, inplace = True)
train['dependency'].value_counts()
yes          2192
no           1747
.5           1497
2             730
1.5           713
.33333334     598
.66666669     487
8             378
.25           260
3             236
4             100
.75            98
.2             90
1.3333334      84
.40000001      84
2.5            77
5              24
.80000001      18
1.25           18
3.5            18
2.25           13
.71428573      12
.83333331      11
1.2            11
.22222222      11
1.75           11
.2857143        9
1.6666666       8
.60000002       8
.16666667       7
6               7
Name: dependency, dtype: int64
Converting object variables into numerical data
def map(i):
    
    if i=='yes':
        return(float(1))
    elif i=='no':
        return(float(0))
    else:
    
        return(float(i))
train['dependency']=train['dependency'].apply(map)
for i in train.columns:
    a=train[i].dtype
    if a == 'object':
        print(i)
edjefe
edjefa
train.info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 9557 entries, 0 to 9556
Columns: 141 entries, v2a1 to Target
dtypes: float64(9), int64(130), object(2)
memory usage: 10.3+ MB
train['edjefe']=train['edjefe'].apply(map)
train['edjefa']=train['edjefa'].apply(map)
train.drop('r4t3',axis=1,inplace=True)
train.parentesco1.value_counts()
0    6584
1    2973
Name: parentesco1, dtype: int64
Identifying Null values
train.isna().sum().value_counts()
0       135
5         2
7928      1
6860      1
7342      1
dtype: int64
#Null Values in Target column
train['Target'].isna().sum()
0
​
float_col=[]
for i in train.columns:
    a=train[i].dtype
    if a == 'float64':
        float_col.append(i)
print(float_col)
['v2a1', 'v18q1', 'rez_esc', 'dependency', 'edjefe', 'edjefa', 'meaneduc', 'overcrowding', 'SQBovercrowding', 'SQBdependency', 'SQBmeaned']
train[float_col].isna().sum()
v2a1               6860
v18q1              7342
rez_esc            7928
dependency            0
edjefe                0
edjefa                0
meaneduc              5
overcrowding          0
SQBovercrowding       0
SQBdependency         0
SQBmeaned             5
dtype: int64
train['v18q1'].value_counts()
1.0    1586
2.0     444
3.0     129
4.0      37
5.0      13
6.0       6
Name: v18q1, dtype: int64
pd.crosstab(train['tipovivi1'],train['v2a1'])
v2a1	0.0	12000.0	13000.0	14000.0	15000.0	16000.0	17000.0	20000.0	23000.0	25000.0	...	570540.0	600000.0	620000.0	684648.0	700000.0	770229.0	800000.0	855810.0	1000000.0	2353477.0
tipovivi1																					
0	29	3	4	3	3	2	4	22	5	21	...	25	11	3	3	7	3	4	11	7	2
1 rows × 157 columns

pd.crosstab(train['v18q1'],train['v18q'])
v18q	1
v18q1	
1.0	1586
2.0	444
3.0	129
4.0	37
5.0	13
6.0	6
train['v2a1'].fillna(0,inplace=True)
train['v18q1'].fillna(0,inplace=True)
train.drop(['tipovivi3', 'v18q','rez_esc','elimbasu5'],axis=1,inplace=True)
train['meaneduc'].fillna(np.mean(train['meaneduc']),inplace=True)
train['SQBmeaned'].fillna(np.mean(train['SQBmeaned']),inplace=True)
print(train.isna().sum().value_counts())
0    136
dtype: int64
int_col=[]
for i in train.columns:
    a=train[i].dtype
    if a == 'int64':
        int_col.append(i)
print(int_col)
train[int_col].isna().sum().value_counts()
['hacdor', 'rooms', 'hacapo', 'v14a', 'refrig', 'r4h1', 'r4h2', 'r4h3', 'r4m1', 'r4m2', 'r4m3', 'r4t1', 'r4t2', 'tamhog', 'tamviv', 'escolari', 'hhsize', 'paredblolad', 'paredzocalo', 'paredpreb', 'pareddes', 'paredmad', 'paredzinc', 'paredfibras', 'paredother', 'pisomoscer', 'pisocemento', 'pisoother', 'pisonatur', 'pisonotiene', 'pisomadera', 'techozinc', 'techoentrepiso', 'techocane', 'techootro', 'cielorazo', 'abastaguadentro', 'abastaguafuera', 'abastaguano', 'public', 'planpri', 'noelec', 'coopele', 'sanitario1', 'sanitario2', 'sanitario3', 'sanitario5', 'sanitario6', 'energcocinar1', 'energcocinar2', 'energcocinar3', 'energcocinar4', 'elimbasu1', 'elimbasu2', 'elimbasu3', 'elimbasu4', 'elimbasu6', 'epared1', 'epared2', 'epared3', 'etecho1', 'etecho2', 'etecho3', 'eviv1', 'eviv2', 'eviv3', 'dis', 'male', 'female', 'estadocivil1', 'estadocivil2', 'estadocivil3', 'estadocivil4', 'estadocivil5', 'estadocivil6', 'estadocivil7', 'parentesco1', 'parentesco2', 'parentesco3', 'parentesco4', 'parentesco5', 'parentesco6', 'parentesco7', 'parentesco8', 'parentesco9', 'parentesco10', 'parentesco11', 'parentesco12', 'hogar_nin', 'hogar_adul', 'hogar_mayor', 'hogar_total', 'instlevel1', 'instlevel2', 'instlevel3', 'instlevel4', 'instlevel5', 'instlevel6', 'instlevel7', 'instlevel8', 'instlevel9', 'bedrooms', 'tipovivi1', 'tipovivi2', 'tipovivi4', 'tipovivi5', 'computer', 'television', 'mobilephone', 'qmobilephone', 'lugar1', 'lugar2', 'lugar3', 'lugar4', 'lugar5', 'lugar6', 'area1', 'area2', 'age', 'SQBescolari', 'SQBage', 'SQBhogar_total', 'SQBedjefe', 'SQBhogar_nin', 'agesq', 'Target']
0    126
dtype: int64
train[int_col].isna().sum().value_counts()
train.Target.value_counts()
4    5996
2    1597
3    1209
1     755
Name: Target, dtype: int64
Setting the poverty level of the members and the head of the house same in the family
Poverty_level=train[train['v2a1'] !=0]
Poverty_level.shape
(2668, 136)
poverty_level=Poverty_level.groupby('area1')['v2a1'].apply(np.median)
def povert(x):
    if x<8000:
        return('Below poverty level')
    
    elif x>140000:
        return('Above poverty level')
    elif x<140000:
        return('Below poverty level: Ur-ban ; Above poverty level : Rural ')
c=Poverty_level['v2a1'].apply(povert)
c.shape
(2668,)
pd.crosstab(c,Poverty_level['area1'])
area1	0	1
v2a1		
Above poverty level	139	1103
Below poverty level: Ur-ban ; Above poverty level : Rural	306	1081
There are 1242 people above poverty level independent of area whether rural or urban
Remaining 1111 people level depends on their area
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
X_data = train.drop('Target', axis=1)
Y_data = train.Target
X_data_col = X_data.columns
from sklearn.preprocessing import StandardScaler
SS=StandardScaler()
X_data_1=SS.fit_transform(X_data)
X_data_1=pd.DataFrame(X_data_1,columns=X_data_col)
X_train,X_test,Y_train,Y_test=train_test_split(x, y, test_size=0.3)
from sklearn.pipeline import Pipeline
from sklearn.model_selection import GridSearchCV
​
rfc=RandomForestClassifier(random_state=0)
parameters={'n_estimators':[10,50,100,300],'max_depth':[3,5,10,15]}
grid=zip([rfc],[parameters])
​
best_=None
​
for i, j in grid:
    a=GridSearchCV(i,param_grid=j,cv=3,n_jobs=1)
    a.fit(X_train,Y_train)
    if best_ is None:
        best_=a
    elif a.best_score_>best_.best_score_:
        best_=a
        
        
print ("Best CV Score",best_.best_score_)
print ("Model Parameters",best_.best_params_)
print("Best Estimator",best_.best_estimator_)
​
Best CV Score 0.8543323566345752
Model Parameters {'max_depth': 15, 'n_estimators': 100}
Best Estimator RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini',
                       max_depth=15, max_features='auto', max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_impurity_split=None,
                       min_samples_leaf=1, min_samples_split=2,
                       min_weight_fraction_leaf=0.0, n_estimators=100,
                       n_jobs=None, oob_score=False, random_state=0, verbose=0,
                       warm_start=False)
RFC=best_.best_estimator_
Model=RFC.fit(X_train,Y_train)
pred=Model.predict(X_test)
print('Model Score of train data : {}'.format(Model.score(X_train,Y_train)))
print('Model Score of test data : {}'.format(Model.score(X_test,Y_test)))
Model Score of train data : 0.980326496442026
Model Score of test data : 0.8832635983263598
Important_features=pd.DataFrame(Model.feature_importances_,X_data_col,columns=['feature_importance'])
​
Top50Features=Important_features.sort_values(by='feature_importance',ascending=False).head(50).index
​
Top50Features
Index(['SQBmeaned', 'meaneduc', 'SQBdependency', 'dependency', 'overcrowding',
       'SQBovercrowding', 'qmobilephone', 'edjefe', 'SQBedjefe',
       'SQBhogar_nin', 'hogar_nin', 'cielorazo', 'r4t1', 'rooms', 'edjefa',
       'v2a1', 'agesq', 'r4h2', 'eviv3', 'age', 'SQBage', 'r4m3', 'r4t2',
       'hogar_adul', 'escolari', 'r4h3', 'epared3', 'r4m1', 'SQBescolari',
       'paredblolad', 'r4m2', 'bedrooms', 'tamviv', 'hhsize', 'tamhog',
       'v18q1', 'hogar_total', 'SQBhogar_total', 'pisomoscer', 'r4h1',
       'etecho3', 'lugar1', 'tipovivi1', 'energcocinar2', 'epared2',
       'energcocinar3', 'area1', 'area2', 'eviv2', 'television'],
      dtype='object')
for i in Top50Features:
    if i not in X_data_col:
        print(i)
X_data_Top50=X_data[Top50Features]
X_train,X_test,Y_train,Y_test=train_test_split(X_data_Top50,Y_data,test_size=0.25,stratify=Y_data,random_state=0)
Model_1=RFC.fit(X_train,Y_train)
pred=Model_1.predict(X_test)
from sklearn.metrics import confusion_matrix,f1_score,accuracy_score
confusion_matrix(Y_test,pred)
array([[ 144,   18,    0,   27],
       [   7,  317,    9,   66],
       [   1,   10,  214,   77],
       [   1,   10,    3, 1486]], dtype=int64)
accuracy_score(Y_test,pred)
0.90418410041841
Using RandomForestClassifier we can predict test_data with accuracy 90.42%
